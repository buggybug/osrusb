/*++

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Copyright (c) 2019 Bohdan Yevtukh. All rights reserved.

Module Name:

    OsrUsbFx2Driver.c

Abstract:

    This module contains the code to initialize the OSR USB FX2 device driver.

Environment:

    Kernel mode only.

--*/

#include "pch.h"
#include "OsrUsbFx2Logging.h"
#include "OsrUsbFx2Private.h"

#if defined (EVENT_TRACING)
//
// The trace message header (.tmh) file must be included in a source file
// before any WPP macro calls and after defining a WPP_CONTROL_GUIDS
// macro (defined in OsrUsbFx2Logging.h). During the compilation, WPP scans
// the source files for OSR_LOG...() calls and builds a .tmh file which stores
// a unique data GUID for each message, the text resource string for each
// message, and the data types of the variables passed in for each message.
// This file is automatically generated and used during post-processing.
//
#include "OsrUsbFx2Driver.tmh"
#endif /* defined (EVENT_TRACING) */

#if (NTDDI_VERSION >= NTDDI_WS03)

//
// This macro returns a preprocessor token that represents a wide char string
// buffer constant name
//
#define OSR_GET_SYSTEN_ROUTINE_STRING_NAME(X)  SystemRoutineName_ ## X

#define OSR_DECLARE_SYSTEM_ROUTINE_STRING(X)  \
    WCHAR OSR_GET_SYSTEN_ROUTINE_STRING_NAME(X)[] = L ## #X

//
// This macro builds the UNICODE_STRING initialization list using a statically
// allocated Unicode character array that is specified in an input parameter
//
#define OSR_SYSTEM_ROUTINE_STRING_INITIALIZATION_LIST(X)  \
    { (sizeof(X) - sizeof((X)[0])), sizeof(X), (X) }

#define OSR_DECLARE_SYSTEM_ROUTINE_TABLE_ENTRY(X)  \
    OSR_SYSTEM_ROUTINE_STRING_INITIALIZATION_LIST(OSR_GET_SYSTEN_ROUTINE_STRING_NAME(X))

//
// Define the data section that will be discarded after DriverEntry returns
//
#if defined (ALLOC_DATA_PRAGMA)
#pragma data_seg(push, init_data, "INITDATA")
#endif /* defined (ALLOC_DATA_PRAGMA) */

OSR_DECLARE_SYSTEM_ROUTINE_STRING (KdRefreshDebuggerNotPresent);

//
// Device driver interface (DDI) version dependent function pointer table
//
// N.B. An order of this table's entries has to much an order of the
//      OSR_SYSTEM_ROUTINE_TABLE structure fields
//

UNICODE_STRING OsrUsbFx2_SystemImportRoutineTable[] = {

    OSR_DECLARE_SYSTEM_ROUTINE_TABLE_ENTRY (KdRefreshDebuggerNotPresent)

};

#if defined (ALLOC_DATA_PRAGMA)
#pragma data_seg(pop, init_data)
#endif /* defined (ALLOC_DATA_PRAGMA) */

#endif /* NTDDI_VERSION >= NTDDI_WS03 */

OSRUSBFX2_DRIVER_GLOBALS OsrUsbFx2_DriverGlobals;

DRIVER_INITIALIZE DriverEntry;
DRIVER_UNLOAD OsrUsbFx2_Unload;

//
// Define the sections that allow for discarding (i.e. paging) some of the code
//

#if defined (ALLOC_PRAGMA)
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, OsrUsbFx2_Unload)
#endif /* defined (ALLOC_PRAGMA) */

__useHeader
NTSTATUS
DriverEntry (
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    DriverEntry initializes the driver and is the first routine called by the
    system after the driver is loaded.

Arguments:

    DriverObject - Represents the instance of the function driver that is loaded
    into memory. DriverEntry must initialize members of DriverObject before it
    returns to the caller. DriverObject is allocated by the system before the
    driver is loaded, and it is released by the system after the system unloads
    the function driver from memory.

    RegistryPath - Represents the driver specific path in the Registry.
    The function driver can use the path to store driver related data between
    reboots. The path does not store hardware instance specific data.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise.

--*/
{
    POSRUSBFX2_DRIVER_GLOBALS driverGlobals;
    PVOID *systemRoutineTable;
    PUNICODE_STRING registryPath;
    PWCH registryPathBuffer;
    ULONG systemImportRoutineTableSize;
    ULONG i;
    USHORT registryPathBufferSize;

#if defined (EVENT_TRACING)
    //
    // On Windowx XP and later, initialize the WPP software tracing by passing
    // the incoming DriverObject and RegistryPath parameters to the OSR_LOG_INIT
    // routine. Windows 2000 requires the function device object (FDO), therefore
    // the OSR_LOG_INIT_WIN2K function is called from the device start routine,
    // i.e. when processing IRP_MN_START_DEVICE
    //
    WppLoadTracingSupport ();
    if (WppTraceWin2K != WPPTraceSuite) {
        OSR_LOG_INIT (DriverObject, RegistryPath);
    }
#endif /* defined (EVENT_TRACING) */

    OSR_LOG_INFORMATION (
        "Initializing %s with parameters: DriverObject=0x%p, RegistryPath=%wZ.",
        OSRUSBFX2_LOGGING_NAME,
        DriverObject,
        RegistryPath
        );

    driverGlobals = OSRUSBFX2_GET_DRIVER_GLOBALS ();

    //
    // Initialize the driver's global data
    //

    //
    // Save a copy of the Unicode string that represents the driver specific path
    // in the Registry, nor the pointer, since the I/O manager frees the string
    // buffer after this routine returns
    //

    registryPathBufferSize = RegistryPath->Length + sizeof(UNICODE_NULL);

    registryPathBuffer = ExAllocatePoolWithTag (
        PagedPool,
        registryPathBufferSize,
        OSRUSBFX2_POOL_TAG
        );

    if (NULL == registryPathBuffer) {
        OSR_LOG_ERROR (
            "Failed to allocate a paged buffer of %u bytes.",
            registryPathBufferSize
            );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    registryPath = &driverGlobals->RegistryPath;

    registryPath->MaximumLength = registryPathBufferSize;
    registryPath->Length = RegistryPath->Length;
    registryPath->Buffer = registryPathBuffer;

    RtlCopyUnicodeString (registryPath, RegistryPath);

#if (NTDDI_VERSION >= NTDDI_WS03)
    //
    // The NTDDI_VERSION stands for the maximum supported Microsoft Windows device
    // driver interface (DDI) version, so it may be efficient to remove meaningless
    // MmGetSystemRoutineAddress calls by using the RtlIsNtDdiVersionAvailable
    // routine to determine current DDI version, yet the performance penalty is
    // disregardable as the system routine table is initialized only once
    //

    systemRoutineTable = (PVOID*) &driverGlobals->SystemRoutineTable;
    systemImportRoutineTableSize = ARRAYSIZE (OsrUsbFx2_SystemImportRoutineTable);

    for (i = 0; i < systemImportRoutineTableSize; ++i) {

        systemRoutineTable[i] = MmGetSystemRoutineAddress (
            &OsrUsbFx2_SystemImportRoutineTable[i]
            );
    }
#endif /* NTDDI_VERSION >= NTDDI_WS03 */
    UNREFERENCED_PARAMETER (systemRoutineTable);
    UNREFERENCED_PARAMETER (systemImportRoutineTableSize);
    UNREFERENCED_PARAMETER (i);

    //
    // Supply entry points for the standard driver's routines
    //

    DriverObject->MajorFunction[IRP_MJ_PNP] = &OsrUsbFx2_DispatchPnP;
    DriverObject->DriverUnload = &OsrUsbFx2_Unload;
    DriverObject->DriverExtension->AddDevice = &OsrUsbFx2_PnPAddDevice;

    return STATUS_SUCCESS;
}

__useHeader
VOID
OsrUsbFx2_Unload (
    PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    OsrUsbFx2_Unload routine performs any operations that are necessary before
    the system unloads the driver.

Arguments:

    DriverObject - Caller-supplied pointer to a DRIVER_OBJECT structure. This is
    the driver's driver object.

Return Value:

    None.

--*/
{
    POSRUSBFX2_DRIVER_GLOBALS driverGlobals;
    PUNICODE_STRING registryPath;

    PAGED_CODE ();

    OSR_LOG_INFORMATION (
        "Unloading driver %s: DriverObject=0x%p.",
        OSRUSBFX2_LOGGING_NAME,
        DriverObject
        );

    ASSERT (NULL == DriverObject->DeviceObject);

    driverGlobals = OSRUSBFX2_GET_DRIVER_GLOBALS ();

    //
    // Deallocate driver-wide resources that were previously allocated in the
    // DriverEntry routine. This operation is synchronous and can be called only
    // after the DriverEntry returns a STATUS_SUCCESS code, otherwise the I/O
    // manager simply frees the memory space taken up by the driver
    //

    //
    // Free the Unicode string representing the path to driver specific key in
    // the Registry. The buffer is guaranteed to be valid
    //

    registryPath = &driverGlobals->RegistryPath;

    ASSERT (NULL != registryPath->Buffer);
    ExFreePoolWithTag (registryPath->Buffer, OSRUSBFX2_POOL_TAG);

#if defined (EVENT_TRACING)
    //
    // On Windows XP and later, deactivate WPP software tracing by passing the
    // DriverObject to the OSR_LOG_CLEANUP routine. On Windows 2000, deactivate
    // WPP software tracing by passing the function device object (FDO) to the
    // OSR_LOG_CLEANUP_WIN2K function when processing IRP_MN_REMOVE_DEVICE
    //
    if (WppTraceWin2K != WPPTraceSuite) {
        OSR_LOG_CLEANUP (DriverObject);
    }
#endif /* defined (EVENT_TRACING) */

    return;
}
